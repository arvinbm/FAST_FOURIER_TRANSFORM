#include "core/cxxopts.h"
#include "core/get_time.h"
#include "core/utils.h"

#include <iostream>
#include <vector>
#include <complex>
#include <cmath>

#include <mpi.h>

#define DEFAULT_NUMBER_OF_SAMPLES "1024"
#define DEFAULT_AMPLITUDE "1.0"
#define DEFAULT_FREQUENCY "50.0"
#define DEFAULT_SAMPLING_RATE "1000.0"

#define PI M_PI
#define BASE 2.0
#define EXPONENTIAL_PART (std::pow(BASE, 2 * PI))
#define IMAGINARY_UNIT std::complex<double>(0, 1)
#define OMEGA(n_samples) ((EXPONENTIAL_PART * IMAGINARY_UNIT) / static_cast<double>(n_samples))

/** 
 * (This comment has been generated by GenAI based on the implementation of the function).
 * @brief Generates a sine wave sampled at regular intervals.
 * 
 * This function creates a sine wave based on the specified number of samples, amplitude,
 * frequency, and sampling rate. The resulting sine wave is represented as a vector of
 * complex numbers, where the real part contains the sine wave values, and the imaginary 
 * part is set to 0.0 (useful for FFT processing).
 * 
 * @param n_samples The total number of samples to generate.
 * @param amplitude The amplitude of the sine wave (peak value).
 * @param frequency The frequency of the sine wave in Hz (cycles per second).
 * @param sampling_rate The rate at which the sine wave is sampled in Hz (samples per second).
 * @return std::vector<std::complex<double>> A vector containing the sampled sine wave values 
 *         as complex numbers with 0.0 as the imaginary part.
 */
std::vector<std::complex<double>> generateSineWave(uint n_samples, double amplitude, double frequency, double sampling_rate) {
    // Vector to store the samples from the sine wave
    std::vector<std::complex<double>> sine_wave(n_samples);

    for (uint n = 0; n < n_samples; ++n) {
        double time_step = n / sampling_rate;
        // Compute the value of the sine wave at the current time step
        double value = amplitude * std::sin(2 * M_PI * frequency * time_step);
        sine_wave[n] = {value, 0.0};
    }

    return sine_wave;
}

// https://www.educative.io/answers/how-to-check-if-a-number-is-a-power-of-2-in-cpp
void validateNumSamplesToBePowerOfTwo(uint n_samples) {
    uint i = n_samples & (n_samples - 1);

    if (i != 0) {
        throw std::invalid_argument("The number of samples provided must be power of two.");
    }
}

/**
 * 
 */
void iterativeFFT_MPI(std::vector<std::complex<double>>& local_data, int local_n, int n, MPI_Comm comm) {
//     using Complex = std::complex<double>;
//     int rank, size;
//     MPI_Comm_rank(comm, &rank);
//     MPI_Comm_size(comm, &size);

//     int log_n = std::log2(n);
    
//     // Perform bit-reversal ordering
//     std::vector<Complex> temp(n);
//     MPI_Allgather(local_data.data(), local_n, MPI_DOUBLE_COMPLEX, temp.data(), local_n, MPI_DOUBLE_COMPLEX, comm);
    
//     size_t j = 0;
//     for (size_t i = 1; i < n; ++i) {
//         size_t bit = n >> 1;
//         while (j & bit) {
//             j ^= bit;
//             bit >>= 1;
//         }
//         j ^= bit;

//         if (i < j) {
//             std::swap(temp[i], temp[j]);
//         }
//     }

//     local_data.assign(temp.begin() + rank * local_n, temp.begin() + (rank + 1) * local_n);

//     for (int stage = 1; stage <= log_n; ++stage) {
//         int len = 1 << stage;    // current stage
//         double angle = -2.0 * PI / len;
//         Complex wlen(std::cos(angle), std::sin(angle));

//         for (int i = 0; i < local_n; i += len) {
//             Complex w(1.0);
//             for (int j = 0; j < len / 2; ++j) {
//                 int index1 = i + j;
//                 int index2 = index1 + len / 2;

//                 Complex u = local_data[index1];
//                 Complex v = local_data[index2] * w;
//                 local_data[index1] = u + v;
//                 local_data[index2] = u - v;

//                 w *= wlen;
//             }
//         }

//         // Exchange results between processes
//         int partner = rank ^ (1 << (stage - 1));
//         std::cout << "Process #" << rank << " has a partner of #" << partner << std::endl;

//         if (partner < size) {
//             MPI_Sendrecv_replace(local_data.data(), local_n, MPI_DOUBLE_COMPLEX, partner, 0, partner, 0, comm, MPI_STATUS_IGNORE);
//         }
//     }

    using Complex = std::complex<double>;
    int rank, size;
    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    // All-to-all gather
    std::vector<Complex> global_data(n);
    MPI_Allgather(local_data.data(), local_n, MPI_DOUBLE_COMPLEX, 
                  global_data.data(), local_n, MPI_DOUBLE_COMPLEX, comm);

    // Perform FFT on the gathered global data
    int log_n = std::log2(n);
    
    for (int stage = 1; stage <= log_n; ++stage) {
        int len = 1 << stage;    // 2^stage
        double angle = -2.0 * PI / len;
        Complex wlen(std::cos(angle), std::sin(angle));

        for (int i = 0; i < n; i += len) {
            Complex w(1.0);
            for (int j = 0; j < len / 2; ++j) {
                int index1 = i + j;
                int index2 = index1 + len / 2;
                Complex u = global_data[index1];
                Complex v = global_data[index2] * w;
                global_data[index1] = u + v;
                global_data[index2] = u - v;
                w *= wlen;
            }
        }
    }

    // Redistribute results back to local processes
    MPI_Scatter(global_data.data(), local_n, MPI_DOUBLE_COMPLEX, 
                local_data.data(), local_n, MPI_DOUBLE_COMPLEX, 0, comm);
}


void printFirstOutputs(std::vector<std::complex<double>>& output_signal, uint n_samples) {

    if (n_samples <= 8) {
        // If there are only a few samples print all of the results
        std::cout << std::endl;
        std::cout << "First " << n_samples << " samples:" << std::endl;
        int item_counter = 1;
        for (const auto& item : output_signal) {
            std::cout << item_counter << ". " << item << std::endl;
            item_counter++;
        }
    } else {
        // If there are more samples only print the first 10
        std::cout << std::endl;
        std::cout << "First 10 samples:" << std::endl;
        for (int i = 1; i < 11; i++) {
            std::cout << i << ". " << output_signal[i] << std::endl;
        }
    }     
}

int main(int argc, char *argv[]) {
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    cxxopts::Options options(
        "Fast_Fourier_Transfrom",
        "Calculate the Fourier Transform of a sine wave using serial execution.");
    options.add_options(
        "",
        {
            {"nSamples", "Number of Samples", 
            cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_SAMPLES)},
            {"amplitude", "Amplitude of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_AMPLITUDE)},
            {"frequency", "Frequency of the Sine Wave",
            cxxopts::value<double>()->default_value(DEFAULT_FREQUENCY)},
            {"samplingRate", "Sampling Rate",
            cxxopts::value<double>()->default_value(DEFAULT_SAMPLING_RATE)}
        });

    auto cl_options = options.parse(argc, argv);
    uint n_samples = cl_options["nSamples"].as<uint>();
    double amplitude = cl_options["amplitude"].as<double>();
    double frequency = cl_options["frequency"].as<double>();
    double sampling_rate = cl_options["samplingRate"].as<double>();

    // Print the command line inputs
    std::cout << "Number of Samples: " << n_samples << std::endl;
    std::cout << "Amplitude: " << amplitude << std::endl;
    std::cout << "Frequency: " << frequency << " Hz" << std::endl;
    std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;

    try {
        validateNumSamplesToBePowerOfTwo(n_samples);
    } catch (const std::invalid_argument& error) {
        if (rank == 0) std::cerr << error.what() << std::endl;
        MPI_Finalize();
        return EXIT_FAILURE;
    }

    // Print the command line inputs
    if (rank == 0) {
        std::cout << "Number of Samples: " << n_samples << std::endl;
        std::cout << "Amplitude: " << amplitude << std::endl;
        std::cout << "Frequency: " << frequency << " Hz" << std::endl;
        std::cout << "Sampling Rate: " << sampling_rate << " Hz" << std::endl;
    }

    uint local_n = n_samples / size;

    // Generate a sine wave to be used for Fast Fourier Transform
    auto local_data = generateSineWave(local_n, amplitude, frequency, sampling_rate);

    // Measure time (using MPI Wtime method)
    MPI_Barrier(MPI_COMM_WORLD);
    double start_time = MPI_Wtime();

    // Perform parallel FFT
    iterativeFFT_MPI(local_data, local_n, n_samples, MPI_COMM_WORLD);
    // Perform Fast Fourier Transform serially
    // auto fast_fourier_transform_result = performFastFourierTransformSerial(local_data);

    MPI_Barrier(MPI_COMM_WORLD);
    double end_time = MPI_Wtime();

    if (rank == 0) {
        std::cout << "Parallel FFT completed in " << (end_time - start_time) << " seconds.\n";
    }

    // Gather results to root
    std::vector<std::complex<double>> global_data;
    if (rank == 0) {
        global_data.resize(n_samples);
    }
    MPI_Gather(local_data.data(), local_n, MPI_DOUBLE_COMPLEX, global_data.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);

    // Print the fist few outputs
    if (rank == 0) {
        printFirstOutputs(global_data, n_samples);
    }

    MPI_Finalize();
    return 0;
}